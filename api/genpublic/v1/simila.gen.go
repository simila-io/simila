// Package similapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package similapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for NodeType.
const (
	Document NodeType = "document"
	Folder   NodeType = "folder"
)

// CreateRecordsRequest The object is used for records creation.
type CreateRecordsRequest struct {
	// Document The binary data for the document of the specified format.
	Document []byte `json:"document"`

	// NodeType The object describes the index node type.
	NodeType NodeType `json:"nodeType"`

	// Parser The parser name (format name) to be used for the document body.
	Parser string `json:"parser"`

	// RankMultiplier The priority coefficient (must be >= 1.0) of the records within a search result set, the value is overridden by the rankMultiplier value specified for an individual record.
	RankMultiplier float32 `json:"rankMultiplier"`

	// Records The list of records that must be added to the node.
	Records []Record `json:"records"`

	// Tags The object describes the node tags.
	Tags Tags `json:"tags"`
}

// CreateRecordsResult The object is used as a response of the records creation request.
type CreateRecordsResult struct {
	// NodesCreated The list of nodes created.
	NodesCreated []Node `json:"nodesCreated"`

	// RecordsCreated The number of records created.
	RecordsCreated int `json:"recordsCreated"`
}

// DeleteNodesRequest The object is used to delete multiple nodes at a time
type DeleteNodesRequest struct {
	// FilterConditions The filter conditions. The filters support `and`, `or` and `not` conditions for `format`, `path` and `tag("name")`, for instance, `tag("public") = "true" and format = "spreadsheetsData" and (path = "/orgs/1234/balance.xlsx" or path like "/org%"))`.
	FilterConditions string `json:"filterConditions"`

	// Force The flag allows to delete children of a matched node, even if they don't meet the filter criteria
	Force bool `json:"force"`
}

// Format The object describes a data format.
type Format struct {
	// Basis The format basis specifies format dimensions.
	Basis []byte `json:"basis"`

	// Name The format name, it is used as the format identifier.
	Name string `json:"name"`
}

// Formats The object is used as a response of the formats list request.
type Formats struct {
	// Formats Contains a list of formats.
	Formats []Format `json:"formats"`
}

// ListNodesResult The object is used as a response of the nodes list request.
type ListNodesResult struct {
	// Items The list of nodes.
	Items []Node `json:"items"`
}

// ListRecordsResult The object is used a response to the list records request.
type ListRecordsResult struct {
	// NextPageId The id of the next page for getting the rest of the records.
	NextPageId *string `json:"nextPageId,omitempty"`

	// Records The list of found records.
	Records *[]Record `json:"records,omitempty"`

	// Total The total number of found records.
	Total int `json:"total"`
}

// Node The object describes the index node.
type Node struct {
	// Name The node name, must be unique among the siblings in the tree.
	Name string `json:"name"`

	// Path The node path, does not include the name part.
	Path string `json:"path"`

	// Tags The object describes the node tags.
	Tags Tags `json:"tags"`

	// Type The object describes the index node type.
	Type NodeType `json:"type"`
}

// NodeType The object describes the index node type.
type NodeType string

// PatchRecordsRequest The object is used to upsert and delete the node records.
type PatchRecordsRequest struct {
	// DeleteRecords The records to be deleted for the node.
	DeleteRecords []Record `json:"deleteRecords"`

	// UpsertRecords The records to be upserted for the node.
	UpsertRecords []Record `json:"upsertRecords"`
}

// PatchRecordsResult The object is used as a response to the patch records request.
type PatchRecordsResult struct {
	// Deleted The number of deleted records.
	Deleted int `json:"deleted"`

	// Upserted The number of upserted records.
	Upserted int `json:"upserted"`
}

// Record The object contains information about the index record.
type Record struct {
	// Format The format of the record.
	Format string `json:"format"`

	// Id The record identifier within the node.
	Id string `json:"id"`

	// RankMultiplier The priority coefficient (must be >= 1.0) of the record within a search result set.
	RankMultiplier float32 `json:"rankMultiplier"`

	// Segment The searchable text for the record.
	Segment string `json:"segment"`

	// Vector The vector data for the segment.
	Vector []byte `json:"vector"`
}

// SearchRecordsRequest The object is used to perform search across the index records.
type SearchRecordsRequest struct {
	// FilterConditions The filter conditions. The filters support `and`, `or` and `not` conditions for `format`, `path` and `tag("name")`, for instance, `tag("public") = "true" and format = "spreadsheetsData" and (path = "/orgs/1234/balance.xlsx" or prefix(path, "/org"))`.
	FilterConditions string `json:"filterConditions"`

	// GroupByPathOff The flag turns off results grouping by path.
	GroupByPathOff bool `json:"groupByPathOff"`

	// Limit The maximum number of records per page.
	Limit int `json:"limit"`

	// Offset The number of records to skip before start returning results.
	Offset int `json:"offset"`

	// TextQuery The text query. The query must be formed in accordance with the query language of the underlying search engine.
	TextQuery string `json:"textQuery"`
}

// SearchRecordsResult The object is used as a response to the search records request.
type SearchRecordsResult struct {
	// Items The found index records.
	Items []SearchRecordsResultItem `json:"items"`

	// Total The total number of found records.
	Total int `json:"total"`
}

// SearchRecordsResultItem The object is used as an item in the search records response.
type SearchRecordsResultItem struct {
	// MatchedKeywords The matched keywords within the record.
	MatchedKeywords []string `json:"matchedKeywords"`

	// Path The path of the record.
	Path string `json:"path"`

	// Record The object contains information about the index record.
	Record Record `json:"record"`

	// Score The relevancy score of the record.
	Score float32 `json:"score"`
}

// Tags The object describes the node tags.
type Tags map[string]string

// ConditionFilter defines model for ConditionFilter.
type ConditionFilter = string

// CreatedAfterFilter defines model for CreatedAfterFilter.
type CreatedAfterFilter = time.Time

// CreatedBeforeFilter defines model for CreatedBeforeFilter.
type CreatedBeforeFilter = time.Time

// Force defines model for Force.
type Force = bool

// FormatFilter defines model for FormatFilter.
type FormatFilter = string

// FormatId defines model for FormatId.
type FormatId = string

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// PageId defines model for PageId.
type PageId = string

// Path defines model for Path.
type Path = string

// TagsFilter The object describes the node tags.
type TagsFilter = Tags

// ListNodesParams defines parameters for ListNodes.
type ListNodesParams struct {
	// Condition The condition contatins the simila QL expression to select nodes by the filter
	Condition *ConditionFilter `form:"condition,omitempty" json:"condition,omitempty"`

	// Offset The offset defines the number of the objects that should be skipped in the result response
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The limit defines the max number of objects returned per page.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteNodeParams defines parameters for DeleteNode.
type DeleteNodeParams struct {
	// Force force flag specifies whether the operation will force the request.
	Force *Force `form:"force,omitempty" json:"force,omitempty"`
}

// ListNodeRecordsParams defines parameters for ListNodeRecords.
type ListNodeRecordsParams struct {
	// Format The format specifies the format to filter the records by.
	Format *FormatFilter `form:"format,omitempty" json:"format,omitempty"`

	// CreatedAfter The createdAfter specifies the lowest creation time (exclusive) the resulting records can have.
	CreatedAfter *CreatedAfterFilter `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore The createdBefore specifies the greatest creation time (exclusive) the resulting records can have.
	CreatedBefore *CreatedBeforeFilter `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// PageId The pageId specifies from which page to start return results.
	PageId *PageId `form:"pageId,omitempty" json:"pageId,omitempty"`

	// Limit The limit defines the max number of objects returned per page.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateNodeRecordsMultipartBody defines parameters for CreateNodeRecords.
type CreateNodeRecordsMultipartBody struct {
	// File The document binary data in the specified format.
	File *openapi_types.File `json:"file,omitempty"`

	// Meta The object is used for records creation.
	Meta *CreateRecordsRequest `json:"meta,omitempty"`
}

// CreateFormatJSONRequestBody defines body for CreateFormat for application/json ContentType.
type CreateFormatJSONRequestBody = Format

// DeleteNodesJSONRequestBody defines body for DeleteNodes for application/json ContentType.
type DeleteNodesJSONRequestBody = DeleteNodesRequest

// UpdateNodeJSONRequestBody defines body for UpdateNode for application/json ContentType.
type UpdateNodeJSONRequestBody = Node

// PatchNodeRecordsJSONRequestBody defines body for PatchNodeRecords for application/json ContentType.
type PatchNodeRecordsJSONRequestBody = PatchRecordsRequest

// CreateNodeRecordsJSONRequestBody defines body for CreateNodeRecords for application/json ContentType.
type CreateNodeRecordsJSONRequestBody = CreateRecordsRequest

// CreateNodeRecordsMultipartRequestBody defines body for CreateNodeRecords for multipart/form-data ContentType.
type CreateNodeRecordsMultipartRequestBody CreateNodeRecordsMultipartBody

// SearchJSONRequestBody defines body for Search for application/json ContentType.
type SearchJSONRequestBody = SearchRecordsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List formats
	// (GET /formats)
	ListFormats(c *gin.Context)
	// Create new format
	// (POST /formats)
	CreateFormat(c *gin.Context)
	// Delete format
	// (DELETE /formats/{formatId})
	DeleteFormat(c *gin.Context, formatId FormatId)
	// Get format
	// (GET /formats/{formatId})
	GetFormat(c *gin.Context, formatId FormatId)
	// Delete multiple nodes
	// (DELETE /nodes)
	DeleteNodes(c *gin.Context)
	// List nodes
	// (GET /nodes)
	ListNodes(c *gin.Context, params ListNodesParams)
	// Delete node
	// (DELETE /nodes/{path})
	DeleteNode(c *gin.Context, path Path, params DeleteNodeParams)
	// Update node
	// (PUT /nodes/{path})
	UpdateNode(c *gin.Context, path Path)
	// List node records
	// (GET /nodes/{path}/records)
	ListNodeRecords(c *gin.Context, path Path, params ListNodeRecordsParams)
	// Patch node records
	// (PATCH /nodes/{path}/records)
	PatchNodeRecords(c *gin.Context, path Path)
	// Create node records
	// (POST /nodes/{path}/records)
	CreateNodeRecords(c *gin.Context, path Path)
	// Health check
	// (GET /ping)
	Ping(c *gin.Context)

	// (POST /search)
	Search(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListFormats operation middleware
func (siw *ServerInterfaceWrapper) ListFormats(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListFormats(c)
}

// CreateFormat operation middleware
func (siw *ServerInterfaceWrapper) CreateFormat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateFormat(c)
}

// DeleteFormat operation middleware
func (siw *ServerInterfaceWrapper) DeleteFormat(c *gin.Context) {

	var err error

	// ------------- Path parameter "formatId" -------------
	var formatId FormatId

	err = runtime.BindStyledParameter("simple", false, "formatId", c.Param("formatId"), &formatId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter formatId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteFormat(c, formatId)
}

// GetFormat operation middleware
func (siw *ServerInterfaceWrapper) GetFormat(c *gin.Context) {

	var err error

	// ------------- Path parameter "formatId" -------------
	var formatId FormatId

	err = runtime.BindStyledParameter("simple", false, "formatId", c.Param("formatId"), &formatId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter formatId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFormat(c, formatId)
}

// DeleteNodes operation middleware
func (siw *ServerInterfaceWrapper) DeleteNodes(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteNodes(c)
}

// ListNodes operation middleware
func (siw *ServerInterfaceWrapper) ListNodes(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNodesParams

	// ------------- Optional query parameter "condition" -------------

	err = runtime.BindQueryParameter("form", true, false, "condition", c.Request.URL.Query(), &params.Condition)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter condition: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListNodes(c, params)
}

// DeleteNode operation middleware
func (siw *ServerInterfaceWrapper) DeleteNode(c *gin.Context) {

	var err error

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameter("simple", false, "path", c.Param("path"), &path)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter path: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteNodeParams

	// ------------- Optional query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, false, "force", c.Request.URL.Query(), &params.Force)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter force: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteNode(c, path, params)
}

// UpdateNode operation middleware
func (siw *ServerInterfaceWrapper) UpdateNode(c *gin.Context) {

	var err error

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameter("simple", false, "path", c.Param("path"), &path)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter path: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateNode(c, path)
}

// ListNodeRecords operation middleware
func (siw *ServerInterfaceWrapper) ListNodeRecords(c *gin.Context) {

	var err error

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameter("simple", false, "path", c.Param("path"), &path)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter path: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNodeRecordsParams

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", c.Request.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter format: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "createdAfter" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdAfter", c.Request.URL.Query(), &params.CreatedAfter)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter createdAfter: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "createdBefore" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdBefore", c.Request.URL.Query(), &params.CreatedBefore)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter createdBefore: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pageId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageId", c.Request.URL.Query(), &params.PageId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pageId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListNodeRecords(c, path, params)
}

// PatchNodeRecords operation middleware
func (siw *ServerInterfaceWrapper) PatchNodeRecords(c *gin.Context) {

	var err error

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameter("simple", false, "path", c.Param("path"), &path)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter path: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchNodeRecords(c, path)
}

// CreateNodeRecords operation middleware
func (siw *ServerInterfaceWrapper) CreateNodeRecords(c *gin.Context) {

	var err error

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameter("simple", false, "path", c.Param("path"), &path)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter path: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateNodeRecords(c, path)
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Ping(c)
}

// Search operation middleware
func (siw *ServerInterfaceWrapper) Search(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Search(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/formats", wrapper.ListFormats)
	router.POST(options.BaseURL+"/formats", wrapper.CreateFormat)
	router.DELETE(options.BaseURL+"/formats/:formatId", wrapper.DeleteFormat)
	router.GET(options.BaseURL+"/formats/:formatId", wrapper.GetFormat)
	router.DELETE(options.BaseURL+"/nodes", wrapper.DeleteNodes)
	router.GET(options.BaseURL+"/nodes", wrapper.ListNodes)
	router.DELETE(options.BaseURL+"/nodes/:path", wrapper.DeleteNode)
	router.PUT(options.BaseURL+"/nodes/:path", wrapper.UpdateNode)
	router.GET(options.BaseURL+"/nodes/:path/records", wrapper.ListNodeRecords)
	router.PATCH(options.BaseURL+"/nodes/:path/records", wrapper.PatchNodeRecords)
	router.POST(options.BaseURL+"/nodes/:path/records", wrapper.CreateNodeRecords)
	router.GET(options.BaseURL+"/ping", wrapper.Ping)
	router.POST(options.BaseURL+"/search", wrapper.Search)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbW2/kthX+K4TaIjag2N5sXmogD5sEmxrdNk6yfYoXMEc8mmFWIhWSsj1YzH8vziF1",
	"pzSyvU7z0CfvSBR5rt+5cT8lmS4rrUA5m1x+SipueAkODP36TishndTqrSwcGHwkwGZGVvgwuUze74Bl",
	"zSL8l+NOKsvcDpiVpSw4++kdg4fKgLW4xGlmoYDMMaUFWLbZ09rc758mEnf9vQazT9JE8RKSy6Q9IEkT",
	"m+2g5EiI21f40joj1TY5HNLkOwPcgXiTOzCLBPfWMVtBJnMJnuZC34N1fgWRK0tgJ/CQFbWVd3BKiwzY",
	"unBSbZmBTBthWcYV2/E7OJvjoHfigIlcm5K75DIR3MGXeFqSznP2LeTawArW/MIRb1t693Lc+UOfwt5b",
	"bTKYMpTjY5YXfNvj5H4HbgeGSNUVGM/JvSwK5td7Hn6vwbo5gmlhzJg2WhfAVUNUyd2SsD13IymHh04H",
	"mw70eElu9gskoaSWDdyTdCUWyZEClEN6THtWxd1ufNSVSNIE5SQNiOTSmRqWD38nS+niJxf4ignIpQpS",
	"KPkDU3W5AcN0zvTmN8icZQZcbRQIVoFhFd/OWhRtGBOGVA62YIigH/PcwgxFmt4NSOrIIdMJJLkdanCn",
	"60KwDTD7UVYVCCZVzxfwT6WVhRlq/WHHyL3mW5hTXUXvepaUG12y+53MdvSOYNNx44IIA2F2Tn5+vyPW",
	"dI1WESUHoZmh0bCTzppO2b10uyAYqQQ8zNhX+PUY23rPt3bJ0xzf2pGf0aPHehl+NJDKXw3kyWXyl/Mu",
	"Cp77t/YciUoOSF54QhGRsO5nf9LPHmZmTJAsjEnLagsCvbMD1ADASGZlEMWcBNpe6KwuQc1suZGKmz0T",
	"3HHaD5luvmgMu5GSCHiAZ7QwvNm7CAKnCSr8PT1cFsm/m3WHFDMFO6cv/46h1NlJwCX8cYoa20AnkQEH",
	"Gy1IcxPyDFcf/4VBqSpkc2TO68Ill6/S2PFGaiPdnmUa8lxmEnc/KWvr8PCb+uLiNXzDXp1dnDZSazQT",
	"TJwzC9xkuwYALLiU1t3xogbUqb4DY6QQoJoUZkhkWDnQBuMKHUfeSVHzIpzZY9gjFDHsyZlDW0vabmgm",
	"CGuY40KAQCm74MfkCg5Ke0y33qbx9EAON4bv6Tc6wjpn6bv9r51ZpY3nBaNJO0PvmJ3o+UNLivelpM2E",
	"Wv+zZAQr3I9bxlscH2u9TYh6ecPQLylZDVnYslZ8WhtSotXCR8eKiT5QuHhyF9gG/EDftPqBaKyhdvfJ",
	"cTEFfA8FOEB6HwV/TjNBX7LSKxiCpLhjnIXMcChzj+xtCTLjDQH/2xrBnrHusWW2riptHLvlStym7Fab",
	"W8aVYLdKu9veV+Sftx6qcB0GsbDS8e3JDUWQm+T0NqWVUlnHVQZp87qqN4XMbpJT9g27STDi3ST0eUA/",
	"fGorA1zYHYCz33PHw4oTirS44FybrT1/9dXrr883vMD9zx4K+3CTMG18PC7kRwgL/3aTnJ7eRvEyj+fT",
	"JBfMpnlR6Hvb00m2k4UwoNCIOCu5y3YgSEEpgztQTJLD7JnQ6gvHSgDXK9tYZqQDI3lHSz+R7tvbRKcN",
	"sTFTexvC1oJ5+RcbtKM2LIagNzSmDbfSLubNtKKfgvnHQpagLBnWqkhKicbCMbggZXKATG4ue59mSgPn",
	"5eQ1nrV5AdqnA6QnynpwmwXHfO6Y77RyXCrcuYHHsHY1MAYbmEDj2K4CCTEpvJPWBbx6XrjwgLUsi5ap",
	"IxHimZFhxL7faY75J0TLjveQSgSufXyZD5Pw4JbqHClaWcKD86UNwukWHHUcQs3lRgE6nhSuyZFyXSvR",
	"3+a5qZB2vJipUfBVLxhPjj4Sij1lzRExXZIprEPDtkZrc8CRomZhimo/D1JNTlkr+XsNjJc6qMjKTSHV",
	"1jZlsjMAUR1Vx0vMlAkNlintmFRZUQvfwaHSoeLGRfddn5E2H6+ta+IQG0pa18tl5xTUlFGPVhLD7ZBb",
	"UHXpMa0Qw1z5Q0QU1xisn1CPOs3qyoJxlIOEPKBBub7ZjgpUWvjzku+1dQmVev6Drtr7TDWJp/0RdPgP",
	"PjchI3MZUpWOpBUzmaH6nhifAkZXuNdxkA4aOVZMNIpbQLBGDcc3a6W/Hg/brdOW4pgAg2aWhJY1aYhU",
	"Pk/AUo9vdO16LthV47HkZjGlGwSrKF5JsWSivaSv32NrDPR/1g5Z6IZEuxYWtvO9K78F3xTAHMb+xg0X",
	"pHYHmdMzHSb/btgKC+evyNPHoZdapYH69ty0a8qvaEz8Qvw9DYgrMHhUI2aeGW3txDYjaPz/EnlYIhvI",
	"5cOJTyv82vkieWt0XX27v+Zu92OeL1TLrjbKMp3nTded0aeYr272lMOcRQrfNAwxovuW/EGWdRlp3fQn",
	"I1O41Qsjj+leTtM8g23CNLA3QPDjvXaGMD0JffQnap7Hk110YWque1uif7YJIyrUD1F4hqSgmghMyKb9",
	"2oKrbY35f4CcWgkwxR4JC24AaisVHC+DO1LTWH9hpOe0G9d4Ba1w5ueF5RY8j8TlhdLR1xITMFiVukR4",
	"uXJQ/umqmzk618pdMTyjKUkmQvc6mUo9NLv+Cfv7+VSy6Yh9DKv6YboLYK06pvXKSNDzdREB3fGEwrRZ",
	"z7qs1WbawFwOUsAdV9me0aLp4W0szQtN0XAU+Eeabsd/dHY6EXBDTMwG3oe6jgvvv7y4HihrIoeVVZav",
	"r/i2b6nNqUg/JoZT6fziL7BYMHcyA/bm+upG4ffSFdC9fnN9RTmDsf6rV2cXZxcE1hUoXsnkMnl9dnH2",
	"OpSRxMd5r2W2jQH6O2ldv1fW3nS4EuFt09tDSXvbpt2+uniFfzDlDakYr6pCZvTx+W8Wd/+0cgDaHEEi",
	"ms1+Q2fIGQl3IJitswyszeui2J+Rcdi6LDkGkgFXTR19+WvbpvyAnqFjaZMfSDDOFNy3ndKcSUfNA/WF",
	"Y/CAe+99ZjqUlv/4bZvLefz9Vov9Z5aUF9Rw7n14cf0cUc89b+dBY92kydcXf1+sbNqYTe0YXmBytvey",
	"tmPlBh11Gopq+JC2xn/+qbmJcujK0ik5fuDUNPZZj7qMq36HwRuE9L0kHxaUoB92bzE0+NsgYmoh/ojW",
	"Qvp34H6Nq6Bbct5eyjl8mOj662XpctsSH1HN68WPM7qygtz1RGAlZlpeCmOmac/jBOGOFNxXGYg3Bbap",
	"SRsjakQNfsZUgRKgMgkToxkodwYSogD5A7jerGeozh/AvYAuL/54v51F1eOqlENNDoTeyW7WRWlGseSV",
	"dNmQF8V0ljia7/pLTJOJYT9DjzkjDWxeCK0jI+xVyB2R+C+6bBkF05q+19DFTO7a3lrsXCZ0APDLmH8M",
	"ZdrTmhfTrJdQwG3nTdMkopHy47xkfCv4kB79JNzVW7HSXzN8Uf8bDwRnHHEw7lud3sxpqPWq80+YBq4J",
	"eZS1nmAQQ0drZvSnZwsu82hd0iXAFWrxV3TXhzii/UiAO/bpLID15BP1haqO+MJ/KsFd11UdStC/fIYE",
	"P7wMVPnp7xpwujgizJo4/Lx66Il0hcWf9ya2y2jV7yvEQasbsbyYuXeXv1esj/zXg/VfDa71r/gsTNj/",
	"PGA6bJTNwOn42uJTkpvjJjmxoZ5htnM434HJIi0YGscdsUFa83wjfCHEiM2D1wPIC5CwZBPttVvMnarQ",
	"ZPuc5jDV55w9LPUdBvbAutQ3y6Bylrl7zYTMczCg/LQR/7p9BZZ9yVB2VIlSEkdzHsEdn+tT/GkNK3rz",
	"HaXtk1NuHBX2XyJzw10nM6uZeqK7CN675970cxevtdP6WJ+0BPd0xiKNwj+uuRO76LzGix7f6xl8jp7U",
	"bBHqd44mnRcyc3Mtn2PuhZlAhRqZi/z/AF64Hct2kH1M/Z9w5ZS9ub6iDiwY6vZX5EqmVkqqbQSb8ZRn",
	"Qtt42hSVOY3/EHo6OY+l02eqJxYi0cvEDynIRaLw40cifti2NBQeysB/9UK1c3TM/QfHl9h0bkZNYQwU",
	"U1SjjyCuD4fD4fDfAAAA//+zI66ADjsAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
